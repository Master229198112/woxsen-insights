import { NextRequest, NextResponse } from 'next/server';\nimport { v2 as cloudinary } from 'cloudinary';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/app/api/auth/[...nextauth]/route';\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\n// File type configurations\nconst fileConfigs = {\n  image: {\n    allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/bmp'],\n    maxSize: 5 * 1024 * 1024, // 5MB\n    folder: 'woxsen-insights/images',\n    resourceType: 'image',\n    transformations: [\n      { width: 1200, height: 800, crop: 'limit', quality: 'auto', fetch_format: 'auto' }\n    ]\n  },\n  pdf: {\n    allowedTypes: ['application/pdf'],\n    maxSize: 10 * 1024 * 1024, // 10MB\n    folder: 'woxsen-insights/documents/pdfs',\n    resourceType: 'raw',\n    generateThumbnail: true\n  },\n  document: {\n    allowedTypes: [\n      'application/msword',\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'text/plain',\n      'application/rtf'\n    ],\n    maxSize: 10 * 1024 * 1024, // 10MB\n    folder: 'woxsen-insights/documents/general',\n    resourceType: 'raw'\n  }\n};\n\nexport async function POST(request) {\n  try {\n    // Check authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const formData = await request.formData();\n    const file = formData.get('file');\n    const fileType = formData.get('fileType') || 'auto'; // 'image', 'pdf', 'document', or 'auto'\n\n    if (!file || !(file instanceof File)) {\n      return NextResponse.json({ error: 'No file provided' }, { status: 400 });\n    }\n\n    // Determine file category\n    let category = fileType;\n    if (fileType === 'auto') {\n      if (file.type.startsWith('image/')) {\n        category = 'image';\n      } else if (file.type === 'application/pdf') {\n        category = 'pdf';\n      } else {\n        category = 'document';\n      }\n    }\n\n    const config = fileConfigs[category];\n    if (!config) {\n      return NextResponse.json({ error: 'Unsupported file category' }, { status: 400 });\n    }\n\n    // Validate file type\n    if (!config.allowedTypes.includes(file.type)) {\n      return NextResponse.json({ \n        error: `Invalid file type. Allowed types: ${config.allowedTypes.join(', ')}` \n      }, { status: 400 });\n    }\n\n    // Validate file size\n    if (file.size > config.maxSize) {\n      return NextResponse.json({ \n        error: `File too large. Maximum size: ${Math.round(config.maxSize / (1024 * 1024))}MB` \n      }, { status: 400 });\n    }\n\n    // Convert File to Buffer\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n\n    // Generate unique filename\n    const timestamp = Date.now();\n    const sanitizedName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');\n    const uniqueFilename = `${timestamp}_${sanitizedName}`;\n\n    // Upload to Cloudinary\n    const uploadOptions = {\n      folder: config.folder,\n      public_id: uniqueFilename,\n      resource_type: config.resourceType,\n      use_filename: false,\n      unique_filename: true,\n      overwrite: false,\n      // Add user info to context for tracking\n      context: {\n        uploaded_by: session.user.email,\n        uploaded_at: new Date().toISOString(),\n        original_name: file.name,\n        file_category: category\n      }\n    };\n\n    // Add transformations for images\n    if (category === 'image' && config.transformations) {\n      uploadOptions.transformation = config.transformations;\n    }\n\n    // Add specific configurations for PDFs\n    if (category === 'pdf') {\n      uploadOptions.flags = 'attachment'; // Ensures proper download behavior\n    }\n\n    const uploadResult = await new Promise((resolve, reject) => {\n      cloudinary.uploader.upload_stream(\n        uploadOptions,\n        (error, result) => {\n          if (error) {\n            console.error('Cloudinary upload error:', error);\n            reject(error);\n          } else {\n            resolve(result);\n          }\n        }\n      ).end(buffer);\n    });\n\n    // Prepare response data\n    const responseData = {\n      success: true,\n      url: uploadResult.secure_url,\n      publicId: uploadResult.public_id,\n      originalFilename: file.name,\n      fileSize: file.size,\n      fileType: file.type,\n      category: category,\n      uploadedAt: new Date().toISOString(),\n      format: uploadResult.format,\n      resourceType: uploadResult.resource_type\n    };\n\n    // For PDFs, try to generate a thumbnail preview\n    if (category === 'pdf' && config.generateThumbnail) {\n      try {\n        // Generate thumbnail of the first page\n        const thumbnailResult = await cloudinary.uploader.upload(uploadResult.secure_url, {\n          folder: `${config.folder}/thumbnails`,\n          public_id: `thumb_${uniqueFilename}`,\n          resource_type: 'image',\n          format: 'jpg',\n          transformation: [\n            { width: 300, height: 400, crop: 'fit', page: 1, quality: 'auto' }\n          ],\n          flags: 'attachment'\n        });\n        \n        responseData.thumbnailUrl = thumbnailResult.secure_url;\n      } catch (thumbError) {\n        console.error('PDF thumbnail generation failed:', thumbError);\n        // Don't fail the upload if thumbnail generation fails\n      }\n    }\n\n    // Add image-specific metadata\n    if (category === 'image') {\n      responseData.width = uploadResult.width;\n      responseData.height = uploadResult.height;\n    }\n\n    return NextResponse.json(responseData, { status: 200 });\n\n  } catch (error) {\n    console.error('File upload error:', error);\n    \n    // Handle specific Cloudinary errors\n    if (error.http_code === 413) {\n      return NextResponse.json(\n        { error: 'File too large for upload service' },\n        { status: 413 }\n      );\n    }\n    \n    if (error.http_code === 415) {\n      return NextResponse.json(\n        { error: 'Unsupported file format' },\n        { status: 415 }\n      );\n    }\n\n    return NextResponse.json(\n      { error: 'File upload failed. Please try again.' },\n      { status: 500 }\n    );\n  }\n}\n\n// GET method to retrieve file information\nexport async function GET(request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const publicId = searchParams.get('publicId');\n    const category = searchParams.get('category') || 'image';\n\n    if (!publicId) {\n      return NextResponse.json({ error: 'Public ID required' }, { status: 400 });\n    }\n\n    const config = fileConfigs[category];\n    if (!config) {\n      return NextResponse.json({ error: 'Invalid category' }, { status: 400 });\n    }\n\n    // Get file details from Cloudinary\n    const result = await cloudinary.api.resource(publicId, {\n      resource_type: config.resourceType\n    });\n\n    const fileInfo = {\n      url: result.secure_url,\n      publicId: result.public_id,\n      format: result.format,\n      fileSize: result.bytes,\n      uploadedAt: result.created_at,\n      resourceType: result.resource_type\n    };\n\n    // Add image-specific data\n    if (category === 'image') {\n      fileInfo.width = result.width;\n      fileInfo.height = result.height;\n    }\n\n    return NextResponse.json({\n      success: true,\n      file: fileInfo\n    });\n\n  } catch (error) {\n    console.error('File info retrieval error:', error);\n    \n    if (error.http_code === 404) {\n      return NextResponse.json({ error: 'File not found' }, { status: 404 });\n    }\n\n    return NextResponse.json(\n      { error: 'Failed to retrieve file information' },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE method to remove files\nexport async function DELETE(request) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const publicId = searchParams.get('publicId');\n    const category = searchParams.get('category') || 'image';\n\n    if (!publicId) {\n      return NextResponse.json({ error: 'Public ID required' }, { status: 400 });\n    }\n\n    const config = fileConfigs[category];\n    if (!config) {\n      return NextResponse.json({ error: 'Invalid category' }, { status: 400 });\n    }\n\n    // Delete from Cloudinary\n    await cloudinary.uploader.destroy(publicId, {\n      resource_type: config.resourceType\n    });\n\n    // If it's a PDF with thumbnail, also delete the thumbnail\n    if (category === 'pdf') {\n      try {\n        const thumbnailPublicId = `${config.folder}/thumbnails/thumb_${publicId.split('/').pop()}`;\n        await cloudinary.uploader.destroy(thumbnailPublicId, {\n          resource_type: 'image'\n        });\n      } catch (thumbError) {\n        console.error('Failed to delete PDF thumbnail:', thumbError);\n        // Don't fail the main delete operation\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'File deleted successfully'\n    });\n\n  } catch (error) {\n    console.error('File deletion error:', error);\n    return NextResponse.json(\n      { error: 'Failed to delete file' },\n      { status: 500 }\n    );\n  }\n}"